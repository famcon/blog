---
title: "웹 보안"
category: "TIL"
date: "2022-09-01"
desc: "cors,toekn, csrf"
thumbnail: "../images/secure.png"
alt: "alt"
---

![](https://images.velog.io/images/c-on/post/6f52e9ae-41e1-426e-b87d-5ba9824e174b/image.png)

# 🔎 cors

cors는 Cross-Origin-Resourse-Sharing의 약자로 서로 다른 도메인간 자원 공유를 의미한다.
HTTP헤더를 사용해 출처가 다른 도메인의 요청을 제한하는 기술이 걸려있어 기본적으로는 차단되어있다.

1. 브라우저에서 요청을 보낼 때 헤더의 `Origin`필드에 보내는 출처 즉, 프론트엔드 주소를 담아서 보낸다.
2. 요청을 수령한 서버는 응답을 보낼 때 헤더의 `Acess-Control-Allow-Origin`필드에 리소스 접근이 허용되는 출처 즉, 프론트엔드의 주소를 입력한다.
3. 응답을 받은 브라우저는 `Origin`과 `Acess-Control-Allow-Origin`가 동일하다면 유효한 응답이라고 판단하여 사용자에게 노출한다.

브라우저가 `<script>`에서 생성되는 Cross-site HTTP 요청은 Same-origin policy를 적용받아 요청이 불가해지는 것이다. 서버와 서버 사이에는 CORS가 적용되지 않지만, 프론트엔드에서 백엔드로 요청을 보낼 때 CORS에러가 발생하는 이유가 이 때문이다.

로컬 개발 환경에서도 CORS 는 발생한다. 프론트엔드와 백엔드를 구현하고 둘 사이 통신을 시켰는데 CORS가 발생해서 해결한 적이 있다. 그 이유는 cross-origin은 다음 중 한가지라도 다른 경우를 모두 포함하기 때문이다.

- 프로토콜(http, https)가 다른경우
- 도메인이 다른경우
- 포트가 다른경우

나의 경우 로컬에서 프론트엔드의 주소는 localhost:5000이었고 백엔드의 주소는 localhost:8080이 었다. 따라서 CORS가 발생한것이다.

### CORS는 왜 필요할까?

만약 모든 곳에서 데이터를 요청할 수 있게 된다면 사이트복제가 가능해진다. 사이트복제는 세션을 탈취하는 해킹을 일으키는 등 악의적으로 사용될 수 있기 때문에 브라우저에서 이를 보호하고 필요한 경우에만 서버와 협의하여 요청할 수 있도록 하는 것이 CORS의 역할인셈이다.

### Credential

브라우저가 제공하는 fetch API는 옵션을 설정해주어야만 브라어우저 쿠키나 인증관련 헤더를 요청에 담아준다.

credential이 바로 그 옵션이다.
할당될 수 있는 값은 다음 세가지가 있다.

- same-origin : 같은 도메인끼리 요청만 인증정보를 담는다
- include : 모든 요청에 인증정보를 담는다
- omit : 인증정보를 절대 담지 않는다.

---

<br>

<br>

# 🔎 토큰보안

로그인은 모든 애플리케이션이 공통으로 가지고 있으며 가장 구현하기 힘든 부분이라고 생각된다. 왜냐하면 피해가 서버의 주인이 아니라 사용자에게 고스란히 일어나기 때문이다.

나는 처음에 강의에서 jwt인증 기능을 배웠던대로 브라우저의 로컬 스토리지에 토큰을 저장했었다.

하지만 jwt의 인증방식과 세션 쿠키의 인증방식이 무엇이 다른 지 알아보기 위해 장단점을 찾아보던 중 jwt토큰 인증방식의 두 가지의 보안 문제를 알게되었다.

# XXS

> 참고 : [블로그](https://returnbliss.tistory.com/14)

해커가 요청에 스크립트를 삽입하는 공격기법이다.

통상적으로 input 관련 form을 이용해서 injection이 이루어지는 게시판에서 XSS취약점이 발견된다.

그래서 토큰을 로컬 스토리지에 저장해두면 사용자가 웹사이트를 사용하다가 해커가 심어놓은 코드가 사용자의 토큰을 해커에게 전달하게 된다.

따라서 자바스크립트로 읽을 수 없는 어딘가에 토큰을 저장해야한다.

- 메모리 : 안전성은 있지만 웹사이트를 벗어나면 토큰이 소멸된다.
- httpOnly쿠키 : 브라우저만 읽기 권한이 있고 만료기간전까지 브라우저의 쿠키저장소에서 사라지지 않는다, 모바일은 사용할 수 없다

### 🔨 express 쿠키 설정 방법

- cookie-parser모듈을 설치한다.
- `Access-Control-Allow-Credentials`값을 `true` 로 설정해준다.
  - 클라이언트는 서버에게 cross-origin 요청에서 쿠키를 담기위해 credentails를 “include”로 설정한다. 이때 응답을 받을 때 응답의 헤더에 `Access-Control-Allow-Credentials` 가 true로 설정되어 있어야만 응답을 자바스크립트로 전달해준다.
- `res.cookie("token", token, options)` 를 반환한다.
  - options는 `httpOnly : true` , `domain : 도메인` , `path : "/"` 를 설정해줘야 한다.
  - 도메인은 프론트엔드서버와 백엔드서버가 공통으로 종속하는 상위 도메인을 적어줘야 한다.
  - path는 특정 경로에서만 쿠키가 활성화되도록 하는 것인데 설정한 경로의 하위 경로까지 포함된다.

---

## CSRF

> 참고 : [블로그](https://minkukjo.github.io/cs/2020/08/15/Security-1/)

해커가 접속과 동시에 어떤 곳으로 요청을 보내는 웹사이트를 만들어서 사용자에게 링크를 보낸다. 이 링크에 접속한 사용자는 브라우저에 httpOnly쿠키가 저장되어있을 경우 접속과 동시에 쿠키가 동봉된 요청을 어딘가로 보내게 된다.

만약 해커가 설정한 요청이 은행에 로그인해서 해커의 계좌로 이체시키는 요청이라면 사용자는 해커의 웹사이트에 접속만 했을 뿐인데 자신도 모르게 이체가 진행되는 것이다.

### 🔨 (구)해결방법

csrf 난수를 생성해서 쿠키에 담아 보내고 서버에서는 세션에 그 토큰을 저장한다. 이후 클라이언트가 요청을 보낼 때는 인증토큰과 csrf토큰이 함께 보내지며 csrf토큰이 세션에 저장된 토큰과 같은지 검사해서 csrf 해키을 예방한다.

### 🔨 (신)해결방법

![](https://images.velog.io/images/c-on/post/284ffe50-816a-41c2-bf09-71e422b1a154/image.png)

**sameSite를 특별히 설정하지 않으면 Lax가 기본값으로 설정된다.**

Lax가 설정되면 같은 `<a href>`, `<link href>`, `<form method=get>`를 제외한 요청들은 strict와 같이

동일도메인에만 쿠키를 전송한다.

하지만 도메인을 설정해준 경우 서브도메인에게 까지 쿠키를 전송해준다.

따라서 프론트엔드서버와 백엔드서버가 같은 상위 도메인을 공유하고 있고 sameSite를 Lax로 설정해주면 csrf 해킹을 예방할 수 있다.
