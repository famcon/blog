---
title: "Javascript 기본 문법 (2)"
category: "TIL"
date: "2022-08-01"
desc: "Javascript 기초 문법들에 대하여 정리 2번째"
thumbnail: "../images/javascript-basic-2.png"
alt: "alt"
---

![](https://images.velog.io/images/c-on/post/7d51bd39-96f9-4f2e-85eb-4b40ce9acca9/image.png)

# 🔎 형변환

---

### 숫자형 형변환하기

`Number(value)` 함수를 사용하면 주어진 값(`value`)을 숫자형으로 명시해서 변환할 수 있다.

단, 주어진 값이 숫자 이외의 글자라면 다른 결과가 나올 수도 있다.

> 📌 **예)**
> undefined → NAN
> null → 0
> true || false → 1 || 0
> string →
>
> - 공백 제거 후 남아있는 문자열이 없다면 : 0
> - 그렇지 않다면 숫자를 읽음
> - 변환에 실패하면 NaN

---

### 불린형 형변환하기

논리 연산을 수행할 때 자동으로 불린형 형변환이 이루어진다.

if문에 값이 들어있지 않은 변수를 주었을 때 자동으로 false로 인식하는 것이 이 때문이다.

• 숫자 `0`, `""`, `null`, `undefined`, `NaN`과 같이 직관적으로도 “비어있다고” 느껴지는 값들은 `false`가 된다.

• 그 외의 값은 `true`로 변환된다.

---

<br>

<br>

# 🔎 자료형

---

### 숫자형

- `Infinity` : 어느 숫자든 0으로 나누면 무한대를 얻는다, 또는 직접 `Infinity` 를 입력할 수 있다.
- `NaN` : 부정확하거나 정의되지 않은 수학 연산을 사용하면 NaN이 반환된다.
  ```jsx
  alert("숫자가 아님" / 2) // NaN,
  alert("숫자가 아님" / 2 + 5) // NaN에 어떤 추가연산을 해도 NaN이다.
  ```

> NaN은 NaN과 같지 않다. 이게 무슨 말이냐면
>
> ```jsx
> console.log(NaN === NaN)
> ```
>
> 다음의 결과는 `false` 이다.
> NaN은 자기 자신을 포함하여 그 어떤 값과도 같지 않기 때문이다.
>
> NaN인지 구분하기 위해서는 `isNaN()` 메서드를 사용해야 한다.

---

### BigInt

암호 관련 작업같이 아주 큰 숫자가 필요한 상황이거나 아주 높은 정밀도로 작업을 해야 할 때 큰 숫자가 필요한 데 이때 BigInt를 사용할 수 있다.

`BigInt`형은 길이에 상관없이 정수를 나타낼 수 있다.

정수 리터럴 끝에 `n`을 붙여 만든다.

```jsx
const bigInt = 1234567890123456789012345678901234567890n
```

---

### null

자바스크립트의 `null`은 자바스크립트 이외 언어의 `null`과 성격이 다르다.

자바스크립트에선 `null`을 ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타내는 데 사용한다.

`let age = null;`은 `나이(age)`를 알 수 없거나 그 값이 비어있음을 보여준다.

---

### undefined

`undefined`는 '값이 할당되지 않은 상태’를 나타낼 때 사용한다.

변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 `undefined`가 자동으로 할당된다.

`undefined`를 직접 할당하는 걸 권장하진 않는다. null과 구분짓기 위해서 비어있거나 알 수 없는 상태임을 나타내려면 null을 할당해준다.

<br>

<br>

# 🔎 연산자

---

### ‘+’ 연산

이항 연산자 `+`의 피연산자로 문자열이 전달되면 덧셈 연산자는 덧셈이 아닌 문자열 병합을 수행한다.

```jsx
let s = "my" + "string"
alert(s) // mystring
```

> 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다는 점에 주의해야 한다.

```jsx
const a = "1" + 2 // "12"
const b = 2 + "1" // "21"
```

---

**더 복잡한 식에 대해 알아보자.**

세개의 수가 차례로 더해질 때 다음과 같은 경우는 어떻게 될까?

```jsx
const c = 2 + 2 + "1"
```

순서대로 생각하면 된다.

2와 2를 더하는 것은 숫자와 숫자의 연산이므로 덧셈을 하여 4가된다.

그 후 4와 ‘1’의 연산은 문자열이 포함되어 있으므로 병합을 하여 ‘41’이 된다.

> 이 특성때문에 `+` 연산자를 숫자가 아닌 피연산자 앞에 붙여 숫자형으로의 변환을 일으킨다.

```jsx
let apples = "2"
let oranges = "3"

alert(+apples + +oranges) // 5
```

위가 그 예시이다. 단항 덧셈의 우선순위는 사칙연산보다 높기 때문에 먼저 적용되어 형변환이 먼저 일어난 후 덧셈 연산을 수행한다.

---

### 비교 연산자

- 동등 연산자 `==` : 피연산자를 모두 숫자형으로 바꾼 뒤 비교한다. 따라서 falsy한 값은 모두 0이 되기 때문에 같다고 판단된다.
- 일치연산자 `===` : 형변환 없이 값을 비교한다.

<br>

<br>

# 🔎 객체

---

오직 하나의 데이터만 담을 수 있는 **원시형**과 달리 **객체형**은 다양한 데이터를 담을 수 있다.

---

### 선언

중괄호 `{}` 를 이용해 만들며 중괄호 안에는 ‘키 : 값’ 쌍으로 구성된 프로퍼티를 여러개 넣을 수 있다.

키는 문자형이어야만 하며 값에는 모든 자료형이 허용된다.

이처럼 중괄호를 사용해 객체를 선언하는 것을 **객체리터럴**이라고 한다.

```jsx
let user = {
  // 객체
  name: "John", // 키: "name",  값: "John"
  age: 30, // 키: "age", 값: 30
}
```

예제에서는 프로퍼티 이름이 문자열이지만 따옴표를 붙이지 않았다. 하지만 [식별자 네이밍 규칙](https://velog.io/@hadam/JS-%EC%8B%9D%EB%B3%84%EC%9E%90-%EB%84%A4%EC%9D%B4%EB%B0%8D-%EA%B7%9C%EC%B9%99)(단어 조합, 특수문자사용 등)을 따르지 않는 경우 따옴표를 붙여주어야 한다.

---

### 대괄호 표기법

프로퍼티의 이름이 따옴표로 감싸져있는 경우 점표기법으로 읽을 수 없으며 대괄호 표기법을 사용해야 한다.

또한 코드를 작성하는 순간에는 프로퍼티의 이름을 모를 경우 대괄호 표기법을 사용해야 한다.

```jsx
const keyname = ["a", "b", "c"]

keyname.forEach(key => {
  console.log(obj[key])
})
```

예제의 경우 obj라는 객체가 있을 때 조회하는 key가 무엇인지 코드를 작성할 때는 알 수가 없으므로 대괄호 표기법을 사용했다.

또한, `const key = “a”` 라고 선언을 했더라도 `key` 가 무엇인지는 런타임에서 정의되므로 이 역시 대괄호 표기법을 사용해야 한다.

---

### in 연산자

자바스크립트는 키가 존재하지 않으면 undefined를 출력하므로 이를 확인하기 위해 `if(key === undefined)` 를 사용해서 프로퍼티 존재 여부를 판별하는 것은 매우 잘못된 방법이다.

```jsx
let obj = {
  test: undefined,
}
```

위 경우 obj.test는 undefined로 선언되었다.

만약 key가 없을 경우에 어떤 작업을 처리하는 코드를 작성했을 때 test라는 키가 있는데도 불구하고 작동이 되지 않는 오류가 발생할 것이다.

따라서 이럴 땐 `"test" in obj` 을 사용해서 키의 존재 여부를 판별하는 것이 바람직하다.

---

### 객체정렬방식

객체의 프로퍼티에도 순서가 있다.

기준은 다음과 같다.

- 키가 정수(를 띄는 문자열)일 경우 오름차순으로 정렬
- 정수가 아닐 경우 정의 순서로 정렬

---

### 복사

객체는 변수에 할당될 때 메모리 주소를 넘겨주기 때문에 이 방식으로는 복사가 아닌 공유가 이뤄진다.

복사를 하기 위해선 `Object.assign(dest, [src1, src2, src3...])` 를 사용한다.

> **깊은 복사**
> 객체의 값이 다시 객체인 경우 이 역시 프로퍼티 복사가 아닌 참조값이 복사되어 변경사항이 공유된다.
> 이를 해결하기위해선 값을 하나하나 검사해서 객체인 경우 그 구조도 복사해주는 반복문을 작성해서 사용해야한다.

---

<br>

<br>

# 🔎 this

---

### 사용

`this`는 객체의 메서드를 호출할 때 메서드가 사용된 객체를 나타낸다.

예를들어 메서드가 사용된 객체의 프로퍼티의 값을 사용해야 할 때 `this.프로퍼티이름` 으로 접근하여 사용할 수 있는 것이다.

> `객체.프로퍼티이름` 도 마찬가지로 같은 것에 접근한다. 하지만 객체가 복사되고 변경되었을 때 메서드는 원치않는 값을 참조하는 오류가 발생할 수 있으므로 `this`를 사용하는 것이 좋다.

---

### 다른언어와 다른점

자바스크립트의 this는 다른 언어의 this와 다르다는 얘기를 정말 많이 듣게된다.

JS의 this는 런타임에 결정된다. 따라서 메서드가 어디서 정의되었는지와 상관없이 `.method()`의 점앞의 객체가 this가 된다.

```jsx
function sayHi() {
  alert(this.name)
}

user.f = sayHi
admin.f = sayHi

user.f() // (this == user)
admin.f() // (this == admin)
```

다른 언어의 개발자들은 this가 항상 메서드가 정의된 객체를 참조한다고 생각하기 때문에 혼동하기도 한다.

---

### arrow function의 this

> 화살표 함수는 this가 없다.
> 화살표 함수에서 this를 참조하게 되면 화살표함수가 아닌 외부함수에서 this값을 가져온다.
>
> ```jsx
> let user = {
>   sayHi() {
>     let arrow = () => console.log(this)
>     arrow()
>   },
> }
>
> user.sayHi() // user
> ```

---

<br>

<br>

# 🔎 생성자 함수

---

class로 객체를 만드는 것이 더 깔끔하지만 생성자 함수로도 객체를 만들 수 있음을 알아두자.

다음 두 관례를 따라 생성자 함수를 만든다.

1. 함수 이름의 첫 글자는 대문자로 시작
2. 반드시 `'new'` 연산자를 붙여 실행

```jsx
function User(name) {
  this.name = name

  this.sayHi = function () {
    alert("제 이름은 " + this.name + "입니다.")
  }
}

let user = new User("보라")
```

<br>

<br>

# 🔎 래퍼 객체

---

원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 **원시래퍼객체(Object Wrapper)**를 만들어준다. 사용이 끝나면 객체는 삭제된다.

```jsx
let str = "Hello"

console.log(str.toUpperCase()) // HELLO
```

1. `str` 이 메서드에 접근을 시도할 때 `String` 객체가 만들어진다.
2. 객체의 메서드가 실행되어 새로운 문자열이 반환된다.
3. 객체는 삭제되고 원시값 str만 남는다.

> `String`, `Number` 등 원시 자료형의 이름을 갖는 객체를 생성자로 사용해서는 안된다.
> 이는 혼동을 일으킬 수 있다.
>
> ```jsx
> let zero = new Number(0)
>
> if (zero) {
>   console.log("참")
> }
> ```
>
> zero는 0을 가진 정수 타입이어야 한다. 하지만 생성자를 통해 객체로 만들어졌기 때문에 falsy값이 아닌 truthy 값이 되어 로그가 찍히는 혼란이 야기된다.

<br>

<br>

# 🔎 분해

---

### 배열 분해

```jsx
let arr = ["Bora", "Lee"]
let [firstName, surname] = arr
```

여기까지는 흔히 알고 있는 구조분해할당 방법이다.

구조분해할당을 응용하면 변수를 교환하는 트릭 또한 구현할 수 있다.

```jsx
;[guest, admin] = [admin, guest]
```

추가로 요소를 무시할 수도 있다.

```jsx
let [firstName, , title] = [
  "Julius",
  "Caesar",
  "Consul",
  "of the Roman Republic",
]

alert(title) // Consul
```

쉼표를 이용해서 중간의 요소를 무시하거나 짝이 없는 인덱스는 자연스레 버려진다. 또 할당하고자 하는 변수의 개수가 분해하고자 하는 배열의 길이보다 크면 나머지에는 undefined가 할당된다.

iterable(반복가능한 객체) 역시 배열분해의 성질을 똑같이 갖는다.

```jsx
let [a, b, c] = "abc" // ["a", "b", "c"]
```

---

### 중첩구조 분해

객체나 배열이 다른 객체나 배열을 포함하는 경우, 좀 더 복잡한 패턴을 사용하면 중첩 배열이나 객체의 정보를 추출할 수 있다. 이를 중첩 구조 분해(nested destructuring)라고 부른다.
