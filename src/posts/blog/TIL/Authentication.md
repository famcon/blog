---
title: "Authentication"
category: "TIL"
date: "2022-02-01"
desc: "세션쿠키, JWT, bcrypt"
thumbnail: "../images/Authentication.png"
alt: "alt"
---

로그인/로그아웃을 구현해보자

서버에서 인증(로그인)이란 패스워드와 핀코드로 인증을 하게 된다.

서버는 상태를 보관하지 않는데 어떻게 인증을 할까

사용자가 아이디와 패스워드로 가입을 하고 로그인을 하면 다음 요청에는 로그인이 되어 있는 지 확인하기 위해 총 2가지 방법이 있다.

<br>

# 🔎세션과 쿠키

클라이언트가 서버에 로그인하면 서버는 DB에 존재하는 사용자인지 확인하고 세션을 만든다.

세션에는 사용자의 ID, 세션ID, 유효기간을 세션이라는 DB에 저장한다. 클라이언트에게 세션과 관련된 정보를 쿠키에 담아서 보내준다. 해당쿠키는 브라우저에 의해서만 읽어서 다시 서버에 보내는 조금 안전한 방식으로 이뤄진다.

이 쿠키를 이용해서 다른 요청에서 이 쿠키 정보를 포함해서 보내서 서버는 세션DB에 존재하는지 만료되진 않았는지 확인하고 유효하다면 요청과 관련된 데이터를 클라이언트에게 보내준다.

### 장점

- 세션DB에 모든 세션 정보를 저장하므로 신뢰할 수 있다.
- 클라이언트에서 별도 처리를 하지않고 브라우저에서 쿠키를 처리함으로 간단하다
- HTTPS까지 사용하면 보안성까지 높아진다
- 사용자에 대한 정보를 보내지 않고 세션 정보를 보내므로 사용자를 보호한다.

### 단점

- 세션의 정보를 서버가 보관하므로 stateful하지 않다
  - 한 서버에 세션을 보관하므로 다양한 많은 서버는 하나의 세션에 접속하기 위해 네트워크 요청을 해야해서 분산형 시스템으로 서비스를 디자인했을 때 성능이 떨어지는 경우가 발생한다

<br>

# 🔎JWT (조트)

Json Web Token 의 약자이다.

Json을 이용해서 웹토큰을 주고받는 다는 의미이다.

3가지로 나눠서 사용자의 autentication정보를 담는다.

- 헤더 : 알고리즘과 타입을 명시
- 페이로드 : 주고받을 데이터(인코딩해서 보안처리를 시킴)
- 시그니쳐 : 인코딩하기 위해서 사용하는 비밀키를 인코딩

사용자가 로그인하고 유용한 사용자라면 서버는 조트를 만들어서 사용자엑에 보낸다.

클라이언트는 헤더에 조트를 포함해서 보내면 서버는 이 조트가 유효한지, 수정되었는지, 만료되었는지를 유효성검사를 한 뒤 해당하는 데이터를 클라이언트에게 보낸다.

### 장점

- 서버에 state가 없다.
- 서버를 확장하거나 분산형 시스템으로 만들어도 조트를 만들고 해독하는 동일한 시크릿키만 공유하면 된다.

### 단점

- 만료기한이 없는 조트를 해커가 가로챌 수도 있으므로 보안에 유념해야 한다.

`npm i jsonwebtoken`으로 express에서 사용할 수 있는 jwt모듈을 설치한다.

jwt 모듈의 `sign` API는 `payload`와 `secreatKey`, `option`을 설정할 수 있다.
option에는 대표적으로 언제 토큰의 유효성을 만료시킬 지를 정하는 `expiresIn`이 속성으로 있다.

```jsx
const jwt = require("jsonwebtoken")

const secreatKey = "asdk1lkj1jdlkjga" // 시크릿키는 나만 아는 복잡한 문자열로 비밀번호처럼 작성해준다
const token = jwt.sign(
  {
    id: "userID",
    isAdmin: true,
  },
  secreatKey,
  { expirseIn: 2 }
)
```

[https://jwt.io/](https://jwt.io/)

생성된 토큰을 위 주소에 접속하여 입력하면 id와 isAdmin의 내용을 볼 수 있다.

<br>

클라이언트에게 토큰을 받았다면 verify API로 토큰을 내장하고 있는 id와 isAdmin을 확인할 수 있다.

이때 verify는 err와 decoded를 반환한다. 따라서 `(토큰, 시크릿키, ()=>{})`을 verify에 인자로 전달하면 된다. 콜백함수의 인자는 error와 decoded를 넣어준다. error에는 에러상태가, decoded에는 디코딩 된 상태가 담기므로 이를 적절히 활용한 코드를 이어가면 된다.

<br>

# 🔎bcrypt

사용자의 ID와 password를 DB에 저장할 때 패스워드를 암호화하여 안전하게 보관하는 해싱 알고리즘 모듈이다.

암호화만 가능한 방식이기 때문에, salt를 사용해서 해커가 단기간에 해독할 수 없도록 방지한다.

`npm i bcrypt`

```jsx
const bcrypt = require("bcrypt")

const pw = "abcd1234"
const hashed = bcrypt.hashSync(pw, 10) // 길이가 10개인 salt 사용

console.log(`pw: ${pw}, hashed:, ${hashed}}`)
```

주의할 점은 salt의 길이를 줄일 수록 해시를 하는 시간이 기하급수적으로 증가한다.

서버에서 많은 시간이 소모되면 사용자가 사이트를 나가버리기 때문에 8~10정도를 사용해주는 게 적당할 것 같다.
